---
layout: post
title:  "java排序"
date:   2018-11-20 10:37:21 +0800
tags: 多线程
color: rgb(255,210,132)
cover: '../assets/blogCover/ocean1.jpg'

---

## Java排序
### 1.冒泡排序:
比较相连的两个元素，把大的元素换到最右边。

第一趟排完，最后的一定是最大的元素，所以第二趟排序不需要比较最后一个数。

同理第三趟也不需要比较倒数第二个数，第j趟不需要比较j-1个数。

每一趟比较次数-1.

```
 @Test
    public void bubbleSort(){//冒泡排序
        private int [] arra = {6,3,8,2,9,1};
        int temp;
        for (int i =0;i<arra.length -1;i++){//外层控制多少趟
                for (int j =0 ;j<arra.length -i-1;j++){//内层控制每趟多少次
                    if(arra[j]>arra[j+1]){
                        temp = arra[j];
                        arra[j] = arra[j+1];
                        arra[j+1] = temp;
                    }
                }
            for(int m:arra){//每趟排序之后输出
                System.out.print(m);
            }
            System.out.println("==============");
        }
    }
```
结果是：
    第1趟排序之后：362819==============

    第2趟排序之后：326189==============

    第3趟排序之后：231689==============

    第4趟排序之后：213689==============

    第5趟排序之后：123689==============


### 2.快速排序：
在要排序的数组array中选择一个中间值做为key（array[0]），通过一趟排序之后使数组分成两部分，

以key为中心，key的左边比key小，key的右边比key大，重复排序，直到有顺序。

#### 一趟排序的方法：
定义i=0,j=array.length-1,i是第一个数的下标，j是最后一个数的下标
从右往左找，找到第一个小于key的数，标记为array[j],
从左往右找，找到第一个大于key的数，标记为array[i],
将array[i]与 array[j]交换，
重复这个过程，直到i=j，
然后交换array[i]和key.

<font color="#dd0000">在一趟排序之后，分别递归调用排序方法对key左右两边进行排序</font><br />



```
@Test
    public void testQuickSort(){
        System.out.println(Arrays.toString(arra));
        if (arra.length>0){
            quickSort(arra, 0, arra.length - 1);
        }
        System.out.println(Arrays.toString(arra));
    }

    public void quickSort(int a[],int low,int high){
        if (low > high){//递归算法的出口
            return;
        }
        //存
        int i = low;
        int j = high;
        int key = a[low];
        //完成一趟排序
        while (i < j){
            while (i< j && a[j] > key){//从右往左找到小于key的数据
                j --;
            }
            while (i<j && a[i] <= key ){//从左往右找到大于key的数据
               i ++;
            }
            if (i<j){//交换
                int temp = a[i];
                a[i] = a[j];
                a[j] = temp;
            }
        }
        //调整key的位置
        int temp = a[i];
        a[i] = a[low];
        a[low] = temp;
        quickSort(a, low , i -1);//对key左面的快排
        quickSort(a, i+1 , high);//对key右面的快排
    }

```

结果：
[6, 3, 8, 2, 9, 1]

[1, 2, 3, 6, 8, 9]










